import Testing
import WPFoundation

// MARK: - TimedConfirmation

/// A type that can be used to confirm that an event occurs zero or more times when using
/// ``timedConfirmation(_:expectedCount:timeout:fileID:filePath:line:column:body:)``.
@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
public struct TimedConfirmation: Sendable {
  private final class Counter: Sendable {
    let lock = Lock(0)
  }
  private let confirmation: Confirmation
  private let expectedCount: Int
  private let count = Counter()
  private var sleepTask: Task<Void, Error>

  fileprivate init(
    confirmation: Confirmation,
    expectedCount: Int,
    timeout: Duration
  ) async {
    self.confirmation = confirmation
    self.expectedCount = expectedCount
    if #available(iOS 18, macOS 15, tvOS 18, watchOS 11, *) {
      self.sleepTask = Task(executorPreference: TimedConfirmationExecutor.shared) {
        try await Task.sleep(for: timeout)
      }
    } else {
      self.sleepTask = Task { try await Task.sleep(for: timeout) }
    }
  }
}

// MARK: - Confirm

@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
extension TimedConfirmation {
  /// Confirm this confirmation.
  ///
  /// - Parameters:
  ///   - count: The number of times to confirm this instance.
  ///
  /// As a convenience, this method can be called by calling the confirmation
  /// directly.
  public func confirm(count: Int = 1) {
    self.count.lock.withLock {
      self.confirmation.confirm(count: count)
      $0 += count
      if $0 > self.expectedCount {
        self.sleepTask.cancel()
      }
    }
  }

  /// Confirm this confirmation.
  ///
  /// - Parameters:
  ///   - count: The number of times to confirm this instance.
  ///
  /// As a convenience, this method can be called by calling the confirmation
  /// directly.
  public func callAsFunction(count: Int = 1) {
    self.confirm(count: count)
  }
}

// MARK: - Run

@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
extension TimedConfirmation {
  fileprivate func run<T>(
    body: @Sendable @escaping (TimedConfirmation) async throws -> T
  ) async throws -> T {
    if #available(iOS 18, macOS 15, tvOS 18, watchOS 11, *) {
      return try await withTaskExecutorPreference(TimedConfirmationExecutor.shared) {
        try await self._run(body: body)
      }
    }
    return try await self._run(body: body)
  }

  private func _run<T>(
    body: @Sendable @escaping (TimedConfirmation) async throws -> T
  ) async throws -> T {
    let task = Task { UnsafeTransfer(value: try await body(self)) }
    try? await self.sleepTask.value
    task.cancel()
    return try await task.value.value
  }
}

private struct UnsafeTransfer<T>: @unchecked Sendable {
  let value: T
}

// MARK: - TaskExecutor

// NB: Use a custom executor to prevent timeout test failures due to the cooperative thread-pool
// being starved.
@available(iOS 18, macOS 15, tvOS 18, watchOS 11, *)
private final class TimedConfirmationExecutor: TaskExecutor {
  static let shared = TimedConfirmationExecutor()

  private let queue = DispatchQueue(
    label: "whypeoplekit.timed.confirmation.executor",
    qos: .userInteractive,
    attributes: .concurrent
  )

  func enqueue(_ job: consuming ExecutorJob) {
    let job = UnownedJob(job)
    self.queue.async(flags: .enforceQoS) {
      job.runSynchronously(on: self.asUnownedTaskExecutor())
    }
  }

  func asUnownedTaskExecutor() -> UnownedTaskExecutor {
    UnownedTaskExecutor(ordinary: self)
  }
}

// MARK: - timedConfirmation

/// Confirm that some event occurs during the invocation of a function within a specified time
/// interval.
///
/// This function behaves exactly like `confirmation`, but will run for the specified duration
/// or until the number of confirmations matches `expectedCount`.
///
/// This is useful for testing synchronous APIs that invoke delegates or callback handlers, and
/// cannot be adopted for to swift concurrency.
///
/// ```swift
/// @Test("Food Truck Bakes N Times")
/// func bakes() async {
///   let n = 10
///   await timedConfirmation("Baked buns", expectedCount: n, timeout: .seconds(1)) { bunBaked in
///     foodTruck.eventHandler = { event in
///       if event == .baked(.cinnamonBun) {
///         bunBaked()
///       }
///     }
///     foodTruck.bake(.cinnamonBun, count: n)
///   }
/// }
/// ```
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this function.
///   - expectedCount: The number of times the expected event should occur when
///     `body` is invoked. The default value of this argument is `1`, indicating that the event
///      should occur exactly once. Pass `0` if the event should _never_ occur when `body` is invoked.
///   - timeout: The maximum length of time that the body can run for before an issue is raised.
///   - body: The function to invoke.
/// - Throws: Whatever is thrown by `body`.
/// - Returns: Whatever is returned by `body`.
@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
public func timedConfirmation<T>(
  _ comment: Comment? = nil,
  expectedCount: Int = 1,
  timeout: Duration = .milliseconds(50),
  sourceLocation: SourceLocation = #_sourceLocation,
  body: @Sendable @escaping (TimedConfirmation) async throws -> T
) async rethrows -> T {
  try await confirmation(
    comment,
    expectedCount: expectedCount,
    sourceLocation: sourceLocation
  ) { confirm in
    let timedConfirmation = await TimedConfirmation(
      confirmation: confirm,
      expectedCount: expectedCount,
      timeout: timeout
    )
    return try await timedConfirmation.run(body: body)
  }
}

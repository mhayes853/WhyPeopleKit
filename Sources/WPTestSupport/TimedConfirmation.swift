import Testing
import os

// MARK: - TimedConfirmation

/// A type that can be used to confirm that an event occurs zero or more times when using
/// ``timedConfirmation(_:expectedCount:timeout:fileID:filePath:line:column:body:)``.
public struct TimedConfirmation: Sendable {
  private let confirmation: Confirmation
  private let expectedCount: Int
  private let count = OSAllocatedUnfairLock(initialState: 0)
  private let sleepTask: Task<Void, Error>
  
  fileprivate init(
    confirmation: Confirmation,
    expectedCount: Int,
    timeout: Duration
  ) async {
    self.confirmation = confirmation
    self.expectedCount = expectedCount
    self.sleepTask = Task { try await Task.sleep(for: timeout) }
  }
}

// MARK: - Confirm

extension TimedConfirmation {
  /// Confirm this confirmation.
  ///
  /// - Parameters:
  ///   - count: The number of times to confirm this instance.
  ///
  /// As a convenience, this method can be called by calling the confirmation
  /// directly.
  public func confirm(count: Int = 1) {
    self.count.withLock {
      self.confirmation.confirm(count: count)
      $0 += count
      if $0 > self.expectedCount {
        self.sleepTask.cancel()
      }
    }
  }
  
  /// Confirm this confirmation.
  ///
  /// - Parameters:
  ///   - count: The number of times to confirm this instance.
  ///
  /// As a convenience, this method can be called by calling the confirmation
  /// directly.
  public func callAsFunction(count: Int = 1) {
    self.confirm(count: count)
  }
}

// MARK: - Run

extension TimedConfirmation {
  fileprivate func run<T>(
    body: @Sendable @escaping (TimedConfirmation) async throws -> T
  ) async throws -> T {
    let task = Task { UnsafeTransfer(value: try await body(self)) }
    try? await self.sleepTask.value
    task.cancel()
    return try await task.value.value
  }
}

private struct UnsafeTransfer<T>: @unchecked Sendable {
  let value: T
}

// MARK: - timedConfirmation

/// Confirm that some event occurs during the invocation of a function within a specified time
/// interval.
///
/// This function behaves exactly like `confirmation`, but will run for the specified duration
/// or until the number of confirmations matches `expectedCount`.
///
/// This is useful for testing synchronous APIs that invoke delegates or callback handlers, and
/// cannot be adopted for to swift concurrency.
///
/// ```swift
/// @Test("Food Truck Bakes N Times")
/// func bakes() async {
///   let n = 10
///   await timedConfirmation("Baked buns", expectedCount: n, timeout: .seconds(1)) { bunBaked in
///     foodTruck.eventHandler = { event in
///       if event == .baked(.cinnamonBun) {
///         bunBaked()
///       }
///     }
///     foodTruck.bake(.cinnamonBun, count: n)
///   }
/// }
/// ```
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this function.
///   - expectedCount: The number of times the expected event should occur when
///     `body` is invoked. The default value of this argument is `1`, indicating that the event
///      should occur exactly once. Pass `0` if the event should _never_ occur when `body` is invoked.
///   - timeout: The maximum length of time that the body can run for before an issue is raised.
///   - body: The function to invoke.
/// - Throws: Whatever is thrown by `body`.
/// - Returns: Whatever is returned by `body`.
public func timedConfirmation<T>(
  _ comment: Comment? = nil,
  expectedCount: Int = 1,
  timeout: Duration = .milliseconds(50),
  fileID: String = #fileID,
  filePath: String = #filePath,
  line: Int = #line,
  column: Int = #column,
  body: @Sendable @escaping (TimedConfirmation) async throws -> T
) async rethrows -> T {
  try await confirmation(
    comment,
    expectedCount: expectedCount,
    fileID: fileID,
    filePath: filePath,
    line: line,
    column: column
  ) { confirm in
    let timedConfirmation = await TimedConfirmation(
      confirmation: confirm,
      expectedCount: expectedCount,
      timeout: timeout
    )
    return try await timedConfirmation.run(body: body)
  }
}
